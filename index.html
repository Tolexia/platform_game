<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîµ Platform Game</title>
    <link rel="stylesheet" href="./sweet_alert/sweetalert.min.css">
    <script src="./sweet_alert/sweetalert.min.js"></script>
    <script src="./exit_door.js"></script>
    <script src="./platform.js"></script>
    <script src="./portal.js"></script>
    <script src="./gravity_inverter.js"></script>
    <script src="./levels.js"></script>
</head>
<style>
    *{
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        overflow: hidden;
    }
    body{
        flex-direction: column;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        width: 100lvw;
        height: 100dvh;
        font-family: Arial, Helvetica, sans-serif;
    }
    canvas{
        border: 1px solid black;
    }
    .display_infos{
        position: absolute;
        font-size: 5dvh;
        bottom: calc(10dvh + 2px);
        color: rgba(78, 78, 78, 0.539);
    }
    #restart{
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        right: 2lvw;
        background: transparent;
        border: none;
        cursor: pointer;
    }
    #restart:focus-visible{
        border: none;
    }
    #restart path {
        stroke: rgba(128, 128, 128, 0.622);
    }
    #restart:hover path {
        stroke: rgb(71, 70, 70);
    }
    #display_level{
        left: 2lvw;
    }
    #display_time{
        right: 2lvw;
    }
    #instructions{
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50lvw;
        height: 50dvh;
        text-align: center;
        opacity: .7;
        font-family: Arial, Helvetica, sans-serif;
    }

    #pad{
        display: flex;
        justify-content: space-around;
        width: 100%;
    }
    #pad .spacebar{
        background-color: #888c9d;
        box-shadow: inset 0px 0px 10px white;
        border-radius: 12px;
        width:50%;
    }
    #pad > button {
        width: 10dvh;
        height: 10dvh;
        background-color: #888c9d;
        border-radius: 50%;
        border: 8px solid darkgrey;
    }
    @media screen and (min-width:1360px) {
        canvas{
            width: 100lvw;
            height: 100dvh;
        }
        #pad{
            display: none;
        }
        .display_infos{
            bottom: 2px;
        }
    }
</style>
<body>
    <div id = "instructions"></div>
    <div class = "display_infos" id = "display_level"></div>
    <div class = "display_infos" id = "display_time"></div>
    <button type = "button" id="restart" onclick="restart()">
        <svg width="32px" height="32px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18.364 8.05026L17.6569 7.34315C14.5327 4.21896 9.46734 4.21896 6.34315 7.34315C3.21895 10.4673 3.21895 15.5327 6.34315 18.6569C9.46734 21.7811 14.5327 21.7811 17.6569 18.6569C19.4737 16.84 20.234 14.3668 19.9377 12.0005M18.364 8.05026H14.1213M18.364 8.05026V3.80762" stroke="#1C274C" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
        </svg>
    </button>
    <canvas id="canvas" ></canvas>
    <div id="pad">
        <button id = "joystick_left" type = "button" ontouchstart="press(this, left)" ontouchend="unpress(this, left)"></button>
        <div class="spacebar" ontouchstart="up()"></div>
        <button id = "joystick_right" type = "button" ontouchstart="press(this, right)" ontouchend="unpress(this, right)"></button>
    </div>
</body>
<script>
    var canvas = document.getElementById('canvas')
    var instructions = document.getElementById('instructions')
    var pad = document.getElementById('pad')
    var display_time = document.getElementById('display_time')
    var display_level = document.getElementById('display_level')

    canvas.width = win_width
    canvas.height = win_height
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;

    const coord_x_start = win_width*0.1
    const coord_y_start = win_height*0.95

    const ball = {
        vx: 2,
        vy: 2,
        radius: 5,
        x: 10,
        y: win_height-10,
        color: "blue",
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fillStyle = this.color;
          ctx.fill();
        },
    };

    /* LEVELS */

    var platforms = []
    var portals = []
    var gravity_inverters = []
    var exit 
    var currentLevel = localStorage.getItem('current_level') != null ? + localStorage.getItem('current_level') : 0;
    const paramLevel = (new URL(document.location)).searchParams.get("level")
    if(paramLevel != null) currentLevel = paramLevel
    
    var maxjump 

    function setMaxJump()
    {
        maxjump = currentLevel > 2 ? 2 : 1
    }
    function restart()
    {
        currentLevel = 0
        localStorage.setItem("current_level", currentLevel)
        time = 0
        localStorage.setItem('timer', time)
        launchLevel()
    }
    function launchLevel()
    {
        ball.x = coord_x_start
        ball.y = coord_y_start
        instructions.innerHTML = ""
        if(window["level"+currentLevel])
        {
            window["level"+currentLevel]()
        }
        else
        {
            let pb = localStorage.getItem('pb') != null ? parseInt(localStorage.getItem('pb')) : 9999999999999999
            const levels_finished = localStorage.getItem('countLvls') != null ? parseInt(localStorage.getItem('countLvls')) : countLvls
            if(time < pb || levels_finished != countLvls) 
            {
                pb = time
                localStorage.setItem('pb', pb)
                localStorage.setItem('countLvls', countLvls)
            }
            Swal.fire({
                title: "üéâ GAME OVER üéâ",
                html: `Congratulations !<br/>You made through all the ${levels_finished} levels in:<br/>${convertDurationToReadable()}<br/><br/>Keep in touch, many more are yet to come ! üîµ`,
              });
            time = 0
            currentLevel = 0
            localStorage.setItem('timer', time)
            localStorage.setItem("current_level", 0)
            level0()
        }
        display_level.innerText = currentLevel
        setMaxJump()
    }

    launchLevel()

    let debug = true

    var hasWon = false;
    const diameter = 2*ball.radius
    const bounding_adjuster = ball.radius
    function checkHasWon()
    {
        return (
            ball.x-diameter >= exit.x_start+bounding_adjuster && 
            ball.x-diameter <= exit.x_end+bounding_adjuster && 
            ball.y+diameter >= exit.y_start && 
            ball.y <= exit.y_end
        )
    }

    var teleporting = false

    const isPortrait = screen.orientation.type.match("portrait")

    /* ANIMATION */
    const TARGET_FPS = 60
    const TARGET_DELTA_TIME = 1000 / TARGET_FPS // ~16.67ms pour 60 FPS
    
    let lastTime = performance.now()
    let gravityTickBase = 0.85
    let inertiaBase = isPortrait ? 0.89 : 0.90

    let jumpcount = 0
    let jumpHeight = win_height < 500  ? 8 : (win_width < 500  ? win_height / 48 : win_height / 48)

    let horizontalLimit = 0

    if(win_width < 500) horizontalLimit = win_width * 0.01
    // else if(win_width < 1000) horizontalLimit = win_width * 0.01
    else if(win_width < 1000) horizontalLimit = win_width * 0.0075
    else horizontalLimit = win_width * 0.004

    // console.log("horizontalLimit", horizontalLimit)

    let tick = 20
    if(win_width < 500) tick = 22
    else if(win_width < 1000) tick = 21
    let tick_base = tick
    let horizontalTick = horizontalLimit / tick
    
    // Valeurs de base pour la gravit√© et l'inertie selon le FPS d√©tect√©
    let gravityTick = gravityTickBase
    let inertia = inertiaBase

    function draw() 
    {
        requestAnimationFrame(draw);

        const currentTime = performance.now()
        const deltaTime = currentTime - lastTime
        lastTime = currentTime

        // Calcul du modificateur de vitesse bas√© sur le deltaTime r√©el
        // Si deltaTime est plus grand que le target, on ralentit (modificateur < 1)
        // Si deltaTime est plus petit que le target, on acc√©l√®re (modificateur > 1)
        const speedModifier = deltaTime / TARGET_DELTA_TIME

        // Ajustement de la gravit√© et de l'inertie en fonction de la vitesse d'animation
        // Plus les FPS sont √©lev√©s, plus on r√©duit la gravit√© et on augmente l'inertie
        if (deltaTime < TARGET_DELTA_TIME * 0.7) {
            // FPS tr√®s √©lev√©s (> ~85 FPS)
            gravityTick = gravityTickBase * 0.9
            // inertia = inertiaBase + (1 - inertiaBase) * 0.25

            console.log("FPS tr√®s √©lev√©s")
        } else if (deltaTime < TARGET_DELTA_TIME * 0.85) {
            // FPS √©lev√©s (> ~70 FPS)
            gravityTick = gravityTickBase * 0.9
            inertia = inertiaBase + (1 - inertiaBase) * 0.1

            console.log("FPS √©lev√©s")
        } else {
            // FPS normaux ou bas
            gravityTick = gravityTickBase
            inertia = inertiaBase
            
            tick = tick_base / 2
            horizontalTick = horizontalLimit / tick


            console.log("FPS normaux ou bas")
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        exit.draw();
        ball.draw();

        let blockX = false;
        let blockY = false;
        let height_platform_under_ball = win_height;

        // Utilisation du modificateur de vitesse pour les collisions anticip√©es
        let nextX = ball.x + ball.vx * speedModifier;
        let nextY = ball.y + ball.vy * speedModifier;

        // Draw Platforms
        for (const platform of platforms) {
            platform.draw();

            // V√©rification des collisions anticip√©es pour l'axe Y (vertical)
            if (nextX >= platform.x_start && nextX <= platform.x_end) {
                const nextBottom = nextY + ball.radius;
                const currentBottom = ball.y + ball.radius;
                const platformTop = platform.y_start;
                const platformBottom = platform.y_end;

                // Ball is falling onto the platform
                if (currentBottom <= platformTop && nextBottom >= platformTop) {
                    ball.y = platformTop - ball.radius;
                    blockY = true;
                    ball.vy = 0;
                    jumpcount = 0;
                }

                // Ball is jumping into the platform from below
                if (currentBottom > (platformBottom + ball.radius) && nextY <= (platformBottom + ball.radius)) {
                    ball.y = platformBottom + ball.radius;
                    blockY = true;
                    ball.vy = 0;
                }

                // Platform under ball
                if (ball.y < platform.y_start && platform.y_start < height_platform_under_ball) {
                    height_platform_under_ball = platform.y_start;
                }
            }

            // V√©rification des collisions anticip√©es pour l'axe X (horizontal)
            const nextLeft = nextX - ball.radius;
            const nextRight = nextX + ball.radius;
            const platformLeft = platform.x_start;
            const platformRight = platform.x_end;

            // Ball moving from left to right
            if (nextRight >= platformLeft && nextLeft < platformLeft && ball.y >= platform.y_start && ball.y <= platform.y_end) {
                blockX = true;
                ball.x = platformLeft - ball.radius;  // Adjust the position to the left of the platform
            }

            // Ball moving from right to left
            if (nextLeft <= platformRight && nextRight > platformRight && ball.y >= platform.y_start && ball.y <= platform.y_end) {
                blockX = true;
                ball.x = platformRight + ball.radius;  // Adjust the position to the right of the platform
            }
        }

        // Draw Portals
        for (const portal of portals) {
            portal.draw();
            if (teleporting) continue;

            for (entrance of [portal.entrance, portal.exit]) {
                if (
                    ball.x - diameter >= entrance.x_start + bounding_adjuster &&
                    ball.x - diameter <= entrance.x_end + bounding_adjuster &&
                    ball.y >= entrance.y_start &&
                    ball.y <= entrance.y_end
                ) {
                    ball.x = entrance.bound.x_start + (portal.width / 2);
                    ball.y = entrance.bound.y_start + (portal.height / 2);
                    teleporting = true;
                    setTimeout(() => (teleporting = false), 500);
                    break;
                }
            }
        }

        // Axe Y
        if (blockY && !pressingUp) {
            ball.vy = 0;
        } else if (nextY >= canvas.height - ball.radius) {
            ball.vy = 0;
            jumpcount = 0;
        } else if (nextY < ball.radius) {
            ball.vy = 0;
        }

        // Axe X
        if (blockX) {
            ball.vx = 0;
        } else if (
            nextX >= canvas.width - ball.radius ||
            nextX <= ball.radius
        ) {
            ball.vx = 0;
        }

        // Draw gravity_inverts
        let isInverted = false;
        for (const gravity_inverter of gravity_inverters) {
            gravity_inverter.draw();

            if (
                gravity_inverter.y_start == height_platform_under_ball &&
                ball.x >= gravity_inverter.x_start &&
                ball.x <= gravity_inverter.x_end &&
                ball.y <= gravity_inverter.y_start
            ) {
                ball.vy = -Math.abs(ball.vy);
                isInverted = true;
            }
        }

        // Application du modificateur de vitesse aux d√©placements
        ball.x += ball.vx * speedModifier;
        ball.y += ball.vy * speedModifier;

        // Application du modificateur de vitesse √† la gravit√©
        ball.vy += (isInverted ? -(gravityTick / 2) : gravityTick) * speedModifier;

        // Application du modificateur √† l'inertie
        // Pour maintenir une r√©duction de vitesse constante sur une p√©riode donn√©e,
        // on ajuste l'inertie en fonction du modificateur : i_adjusted = i^m
        // o√π m est le modificateur de vitesse
        const adjustedInertia = Math.pow(inertia, speedModifier)
        ball.vx *= Math.max(0, Math.min(1, adjustedInertia));

        hasWon = checkHasWon();
        if (hasWon) {
            currentLevel++;
            localStorage.setItem("current_level", currentLevel);
            launchLevel();
            hasWon = false;
        }

    }   



    /* MOVES */

    let pressingUp = false
    let pressingDown = false
    let pressingLeft = false
    let pressingRight = false
    document.body.addEventListener("keydown", e => {
        if(e.key == "ArrowUp" && jumpcount < maxjump)
        {
            ball.vy = -jumpHeight
            jumpcount++
        }
        if(e.key == "ArrowLeft")
        {
            pressingLeft = true 
            left()
        }
        if(e.key == "ArrowRight")
        {
            pressingRight = true 
            right()
        }
    })

   

    
    function up(){
        if(jumpcount < maxjump)
        {
            ball.vy = -jumpHeight
            jumpcount++
        } 
    }
    function left(){
        if(ball.vx > -horizontalLimit) ball.vx -= horizontalTick
        if(pressingLeft == true)window.requestAnimationFrame(left)
    }
    function right(){
        if(ball.vx < horizontalLimit) ball.vx += horizontalTick
        if(pressingRight == true)window.requestAnimationFrame(right)
    }
    document.body.addEventListener("keyup", e => {
        if(e.key == "ArrowLeft")
            pressingLeft = false 
        if(e.key == "ArrowRight")
            pressingRight = false 
    })

    function press(button, callback){
        window["pressInterval_"+button.id] = setInterval(() => {
            callback()
        }, 50)
    }
    function unpress(button, callback){
        clearInterval(window["pressInterval_"+button.id])
    }


    screen.orientation.addEventListener("change", ()=> {
        window.location.reload()
    })
    window.addEventListener("resize", ()=> {
        window.location.reload()
    })
    
    
    draw()

    /* TIMER */
    var time = localStorage.getItem('timer') != null ? parseInt(localStorage.getItem('timer')) : 0
    const tick_time = 100 // ms

    function convertDurationToReadable()
    {
        let time_in_seconds = time / 1000 // float

        const milliseconds = time_in_seconds - parseInt(time_in_seconds)

        const hours = parseInt(time_in_seconds / 3600)
        time_in_seconds -= (hours * 3600)

        const minutes = parseInt(time_in_seconds / 60)
        time_in_seconds -= (minutes * 60)

        const seconds = time_in_seconds

        return (hours+":"+minutes+":"+seconds.toFixed(1))
    }
    function refreshTimer()
    {
        display_time.innerText = convertDurationToReadable()

        time += tick_time
        localStorage.setItem('timer', time)
    }
    setInterval(refreshTimer, tick_time)
</script>
</html>