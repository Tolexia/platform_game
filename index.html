<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="./exitdoor.js"></script>
    <script src="./platform.js"></script>
    <script src="./portal.js"></script>
    <script src="./levels.js"></script>
</head>
<style>
    *{
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }
    body{
        flex-direction: column;
        display: flex;
        align-items: center;
        justify-content: flex-start;
        width: 100lvw;
        height: 100dvh;
        overflow: hidden;
    }
    canvas{
        border: 1px solid black;
    }
    #instructions{
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50lvw;
        height: 50dvh;
        text-align: center;
        opacity: .7;
        font-family: Arial, Helvetica, sans-serif;
    }

    #pad{
        display: flex;
        justify-content: space-around;
        width: 100%;
    }
    #pad .spacebar{
        background-color: #888c9d;
        box-shadow: inset 0px 0px 10px white;
        border-radius: 12px;
        width:50%;
    }
    #pad > span {
        width: 8dvh;
        height: 8dvh;
        margin-top: 10px;
        background-color: #888c9d;
        border-radius: 50%;
        border: 8px solid darkgrey;
    }

</style>
<body>
    <div id = "instructions"></div>
    <canvas id="canvas" ></canvas>
    <div id="pad">
        <span ontouchstart="press(left)" ontouchend="unpress(left)"></span>
        <div class="spacebar" ontouchstart="up()"></div>
        <span ontouchstart="press(right)" ontouchend="unpress(right)"></span>
    </div>
</body>
<script>
    var canvas = document.getElementById('canvas')
    var instructions = document.getElementById('instructions')
    var pad = document.getElementById('pad')
    canvas.width = win_width
    canvas.height = win_height
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    let raf;

    const coord_x_start = win_width*0.1
    const coord_y_start = win_height*0.9

    const ball = {
        vx: 2,
        vy: 2,
        radius: 5,
        x: 10,
        y: win_height-10,
        color: "blue",
        draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
          ctx.closePath();
          ctx.fillStyle = this.color;
          ctx.fill();
        },
    };

    /* LEVELS */

    var platforms = []
    var portals = []
    var exit 
    var currentLevel = localStorage.getItem('current_level') != null ? + localStorage.getItem('current_level') : 0;
    const paramLevel = (new URL(document.location)).searchParams.get("level")
    if(paramLevel != null) currentLevel = paramLevel
    
    var maxjump 

    function setMaxJump()
    {
        maxjump = currentLevel > 2 ? 2 : 1
    }
    function launchLevel()
    {
        ball.x = coord_x_start
        ball.Y = coord_y_start
        instructions.innerHTML = ""
        if(window["level"+currentLevel])
        {
            window["level"+currentLevel]()
        }
        else
        {
            alert("Game Over.\n Congrats !")
            localStorage.setItem("current_level", 0)
            currentLevel = 0
            level0()
        }
        setMaxJump()
    }

    launchLevel()
    

    var hasWon = false;
    function checkHasWon()
    {
        
        return (
            ball.x+ball.radius >= exit.x_start && 
            ball.x <= exit.x_end-ball.radius && 
            ball.y+ball.radius >= exit.y_start && 
            ball.y <= exit.y_end-ball.radius
        )
    }

    var teleporting = false
    /* ANIMATION */
    function draw() 
    {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        exit.draw()
        
        if(!hasWon)
            ball.draw();

        let blockX = false
        let blockY = false

        // Draw Platforms
        for(const line of platforms)
        {
            line.draw()
            if(
                ball.x + ball.vx >= line.x_start - ball.radius && 
                ball.x + ball.vx <= line.x_end + ball.radius
            )
            {
                const onFloor = (ball.y + ball.vy  >= line.y_start - ball.radius) && (ball.y + ball.vy <= line.y_end)
                const underneathFloor = (ball.y + ball.vy <= line.y_end + ball.radius) && (ball.y + ball.vy  >= line.y_start) 
                if(
                    onFloor || underneathFloor
                )
                {
                    blockY = true
                    if(onFloor) jumpcount = 0
                }
                if(ball.y + ball.vy  >= line.y_start && ball.y + ball.vy <= line.y_end) blockX = true
            }
        }

        // Draw Portals
        for(const portal of portals)
        {
            portal.draw()
            if(teleporting) continue;

            for(entrance of [portal.entrance, portal.exit])
            {
                
                if(
                    ball.x  >= entrance.x_start + ball.radius && 
                    ball.x  <= entrance.x_end - ball.radius &&
                    ball.y  >= entrance.y_start + ball.radius && 
                    ball.y  <= entrance.y_end - ball.radius
                )
                {
                    console.log("entrance", entrance)
                    console.log("exit", entrance.bound)
                    ball.x = entrance.bound.x_start + (portal.width / 2)
                    ball.y = entrance.bound.y_start + (portal.height / 2)
                    teleporting = true
                    setTimeout(() => teleporting = false, 500)
                    break;
                }
            }
        }
        
        // Y
        if(blockY && !pressingUp)
        {
            ball.vy = 0
        }
        else if ( ball.y + ball.vy >= canvas.height - ball.radius  ) 
        {
            ball.vy = 0;
            jumpcount = 0;
        }
        else if (ball.y + ball.vy < ball.radius) {
            ball.vy = -ball.vy;
        }

        // X
        if(blockX)
        {
            ball.vx = -ball.vx / 2
        }
        else if (
            ball.x + ball.vx >= canvas.width - ball.radius ||
            ball.x + ball.vx <= ball.radius
        ) {
            ball.vx = 0;
        }

        ball.x += ball.vx;
        ball.y += ball.vy;

        ball.vy *= 0.99;
        ball.vy += 0.25;

        ball.vx *= 0.99
        
        hasWon = checkHasWon()
        if(hasWon)
        {
            currentLevel++
            localStorage.setItem("current_level", currentLevel)
            launchLevel()
            hasWon = false
        }
        
        raf = window.requestAnimationFrame(draw);
    }

    /* MOVES */

    let jumpcount = 0
    const jumpHeight = win_height < 500  ? 5 : (win_width < 500  ? 8 : 10)

    let pressingUp = false
    let pressingDown = false
    let pressingLeft = false
    let pressingRight = false
    document.body.addEventListener("keydown", e => {
        if(e.key == "ArrowUp" && jumpcount < maxjump)
        {
            ball.vy = -jumpHeight
            jumpcount++
        }
        if(e.key == "ArrowLeft")
        {
            pressingLeft = true 
            left()
        }
        if(e.key == "ArrowRight")
        {
            pressingRight = true 
            right()
        }
    })

    const horizontalLimit = (win_width < 1000  ? win_width * 0.01 : win_width * 0.0026)
    const horizontalTick = horizontalLimit / 20

    
    function up(){
        if(jumpcount < maxjump)
        {
            ball.vy = -jumpHeight
            jumpcount++
        } 
    }
    function left(){
        if(ball.vx > -horizontalLimit) ball.vx -= horizontalTick
        if(pressingLeft == true)window.requestAnimationFrame(left)
    }
    function right(){
        if(ball.vx < horizontalLimit) ball.vx += horizontalTick
        if(pressingRight == true)window.requestAnimationFrame(right)
    }
    document.body.addEventListener("keyup", e => {
        if(e.key == "ArrowLeft")
            pressingLeft = false 
        if(e.key == "ArrowRight")
            pressingRight = false 
    })

    var pressInterval
    function press(callback){
        pressInterval = setInterval(() => {
            callback()
        }, 50)
    }
    function unpress(callback){
        clearInterval(pressInterval)
    }


    screen.orientation.addEventListener("change", ()=> {
        window.location.reload()
    })
    window.addEventListener("resize", ()=> {
        window.location.reload()
    })
    
    
    draw()
</script>
</html>